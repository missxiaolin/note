## 简介

本质上就是一个分布式kv存储，采用Raft算法保证分布式一致性，实现了分布式锁2和leader选举3的机制。

etcd可以用于配置管理或者是集群的服务注册与发现。

## 特性

- GRPC通信 grpc带来的优势就是http2的多路复用，可以共享相同的TCP链路，大大节省内存占用。
- TTL与Lease租约 TTL：一次请求或一个key可以设置存活时长，API3改为租约机制。
Lease：类似TTL，仍然用于设置存活时长，但不同的是它可以指定一组请求或key共用相同的租约，这样可以合并相同ttl的请求所占用的连接，从而减少必须维持的连接数。一旦到期，与之关联的所有key都将自动删除。
- Watch观察者 ①基于版本的监视。 ②迭代通知.
- 数据模型 保存所有历史数据，也可以压缩。
- 支持事务

## linux

~~~
yum install etcd
~~~

## mac

~~~
brew install etcd
~~~

### etcd v2 v3 同时存在的问题

最近使用 etcd 时候遇到了一个问题，发现用 go 代码调用 clientv3 写进去的 key 和用 etcdctl 的 key 是不一样的，而且两边可以同时读写相同的 key， 但是知确实不相同的。

因为这个问题查了将近两个小时，最后发现，原来 etcd 默认情况下是 v2 和 v3 的客户端 API 共存的，而两个版本的 API 产生和查询的数据时隔离的。

用 etcd 的过程中看了不少的文章，结果恰恰我看的文章里都没有提到这一点，结果当了冤大头，浪费了这么多时间。

其实现在应该大部分人都是用 v3 版本的 API，etcdctl 默认却是 v2的 API。不知道是出于什么考虑没有把 v3 版本 API 作为 etcdctl 的默认 API 版本。

至于我会问到这个问题，也是因为我在开发的过程中想要用 etcdctl 来验证我的代码写进去的数据是否正确，如果我没有用 etcdctl 来读 go 客户端写进去的数据的话，也就不会有这个问题了。如果想要让 etcdctl 默认用 v3 版的 API，可用在使用 etcdctl 之前，设置版本环境变量：

~~~
export ETCDCTL_API=3
etcdctl ...
~~~

如果不想每次使用 etcdctl 是都设置，可以在 .bashrc 或者 .bash_profile 加入该语句：

~~~
export ETCDCTL_API=3
~~~